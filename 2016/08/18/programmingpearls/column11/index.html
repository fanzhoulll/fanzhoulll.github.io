<!DOCTYPE html>
<html>
<head>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    

    <title>
      Sorting (column 11) | Fan Zhou 
    </title>

    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    
      <meta name="author" content="Fan Zhou">
    
    

    <meta name="description" content="IntroductionThis column introduces how to write good quick sorting algorithm. We start with the basic idea of quick sort and a naive implementation. Then we discuss some problems of the first version">
<meta property="og:type" content="article">
<meta property="og:title" content="Sorting (column 11) | Fan Zhou">
<meta property="og:url" content="http://fanzhoulll.github.io/2016/08/18/programmingpearls/column11/index.html">
<meta property="og:site_name" content="Fan Zhou">
<meta property="og:description" content="IntroductionThis column introduces how to write good quick sorting algorithm. We start with the basic idea of quick sort and a naive implementation. Then we discuss some problems of the first version">
<meta property="og:image" content="http://fanzhoulll.github.io/content/images/2016/8/partition1.png">
<meta property="og:image" content="http://fanzhoulll.github.io/content/images/2016/8/partition2.png">
<meta property="og:image" content="http://fanzhoulll.github.io/content/images/2016/8/partition3.png">
<meta property="og:image" content="http://fanzhoulll.github.io/content/images/2016/8/partition4.png">
<meta property="og:updated_time" content="2016-08-19T06:58:33.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Sorting (column 11) | Fan Zhou">
<meta name="twitter:description" content="IntroductionThis column introduces how to write good quick sorting algorithm. We start with the basic idea of quick sort and a naive implementation. Then we discuss some problems of the first version">
<meta name="twitter:image" content="http://fanzhoulll.github.io/content/images/2016/8/partition1.png">
    
    
    
      <link rel="icon" type="image/x-icon" href="/favicon.png">
    
    <link rel="stylesheet" href="/css/uno.css">
    <link rel="stylesheet" href="/css/highlight.css">
    <link rel="stylesheet" href="/css/archive.css">
    <link rel="stylesheet" href="/css/china-social-icon.css"><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>
<body>

    <!-- hexo-inject:begin --><!-- hexo-inject:end --><span class="mobile btn-mobile-menu">
        <i class="icon icon-list btn-mobile-menu__icon"></i>
        <i class="icon icon-x-circle btn-mobile-close__icon hidden"></i>
    </span>

    

<header class="panel-cover panel-cover--collapsed">


  <div class="panel-main">

  
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        

        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage">Fan Zhou</a></h1>
        <hr class="panel-cover__divider" />

        

        <div class="navigation-wrapper">

          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">

              
                
                <li class="navigation__item"><a href="/#blog" title="" class="blog-button">首页</a></li>
              
                
                <li class="navigation__item"><a href="/about" title="" class="">关于</a></li>
              
                
                <li class="navigation__item"><a href="/archive" title="" class="">归档</a></li>
              

            </ul>
          </nav>

          <!-- ----------------------------
To add a new social icon simply duplicate one of the list items from below
and change the class in the <i> tag to match the desired social network
and then add your link to the <a>. Here is a full list of social network
classes that you can use:

    icon-social-500px
    icon-social-behance
    icon-social-delicious
    icon-social-designer-news
    icon-social-deviant-art
    icon-social-digg
    icon-social-dribbble
    icon-social-facebook
    icon-social-flickr
    icon-social-forrst
    icon-social-foursquare
    icon-social-github
    icon-social-google-plus
    icon-social-hi5
    icon-social-instagram
    icon-social-lastfm
    icon-social-linkedin
    icon-social-medium
    icon-social-myspace
    icon-social-path
    icon-social-pinterest
    icon-social-rdio
    icon-social-reddit
    icon-social-skype
    icon-social-spotify
    icon-social-stack-overflow
    icon-social-steam
    icon-social-stumbleupon
    icon-social-treehouse
    icon-social-tumblr
    icon-social-twitter
    icon-social-vimeo
    icon-social-xbox
    icon-social-yelp
    icon-social-youtube
    icon-social-zerply
    icon-mail

-------------------------------->

<!-- add social info here -->



        </div>

      </div>

    </div>

    <div class="panel-cover--overlay"></div>
  </div>
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner entry">
            

<article class="post-container post-container--single">

  <header class="post-header">
    
    <h1 class="post-title">Sorting (column 11)</h1>

    

    <div class="post-meta">
      <time datetime="2016-08-18" class="post-meta__date date">2016-08-18</time> 

      <span class="post-meta__tags tags">

          
            <font class="categories">
            &#8226; 分类:
            <a class="categories-link" href="/categories/Notes-of-Programming-Pearls/">Notes of Programming Pearls</a>
            </font>
          

          
             &#8226; 标签:
            <font class="tags">
              <a class="tags-link" href="/tags/programming-pearls/">programming pearls</a>
            </font>
          

      </span>
    </div>
    
    

  </header>

  <section id="post-content" class="article-content post">
    <h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>This column introduces how to write <em>good</em> quick sorting algorithm. We start with the basic idea of quick sort and a naive implementation. Then we discuss some problems of the first version algorithm as well as some fix techniques.</p>
<h2 id="Basic-quick-sort"><a href="#Basic-quick-sort" class="headerlink" title="Basic quick sort"></a>Basic quick sort</h2><p>The basic idea of quick sort is <em>divide and conquer</em>. To sort an array we can divide it into two subarrays and recursively sort them. Specifically, we choose an pivotal <em>t</em> and <em>partition</em> the array around it by moving elements smaller than <em>t</em> to the left side of <em>t</em> and greater element to the right side. Then we recursively partition the subarrays on both sides of <em>t</em>. Finally, the entire array is sorted.</p>
<p>With this idea it is quick to write following pseudocode:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">qsort</span><span class="params">(l, u)</span>:</span></div><div class="line">    <span class="keyword">if</span> l &gt;= u:</div><div class="line">      <span class="comment"># at most one element, do nothing</span></div><div class="line">      <span class="keyword">return</span></div><div class="line">    m = partition(l, u)</div><div class="line">    qsort(l, m<span class="number">-1</span>)</div><div class="line">    qsort(m+<span class="number">1</span>, u)</div></pre></td></tr></table></figure>
<p>Next problem is how to partition array around <em>t</em>. In naive implementation, we simply choose the first element of array as pivotal <em>t</em>. Then we scan the array from left to right, and use variable <em>i</em> and <em>m</em> to maintain the following invariant:</p>
<p><img src="/content/images/2016/8/partition1.png" alt="partition1"></p>
<p>When the loop terminate we should have:</p>
<p><img src="/content/images/2016/8/partition2.png" alt="partition2"></p>
<p>Finally we swap <code>x[l]</code> and <code>x[m]</code> to get the partitioned array:</p>
<p><img src="/content/images/2016/8/partition3.png" alt="partition3"></p>
<p>The code for this single-side partition is:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">partion1</span><span class="params">(x, l, u)</span>:</span></div><div class="line">    m = l</div><div class="line">    i = l+<span class="number">1</span></div><div class="line">    <span class="keyword">while</span> i&lt;=u:</div><div class="line">        <span class="string">'''</span></div><div class="line">        Invariant:  arr[l+1 ...m] &lt;  x[l]</div><div class="line">                    arr[m+1..i-1] &gt;= x[l]</div><div class="line">        '''</div><div class="line">        <span class="keyword">if</span> x[i] &lt; x[l]:</div><div class="line">            m += <span class="number">1</span></div><div class="line">            swap(x, m, i)</div><div class="line">        i += <span class="number">1</span></div><div class="line">    swap(x, l, m)</div><div class="line">    <span class="keyword">return</span> m</div></pre></td></tr></table></figure>
<p>The best-case time complexity of quick sorting is O(<em>nlog(n)</em>). To understand why, assuming each partition divide array into two sub-arrays with equal size. The the total run time is:</p>
<pre><code>T(n) = 2*T(n/2) + O(n)
</code></pre><p>where <em>n</em> is the input array size. So we have <em>T(n) = O(nlog(n))</em>. However, this only holds when averagely speaking, the two sub-arrays after partition have equal sizes. Otherwise, the total run time would be much longer, as we will see in following section.</p>
<h2 id="Better-quick-sort"><a href="#Better-quick-sort" class="headerlink" title="Better quick sort"></a>Better quick sort</h2><h3 id="Two-sided-partition"><a href="#Two-sided-partition" class="headerlink" title="Two-sided partition"></a>Two-sided partition</h3><p>When the input array is not random, the above algorithm could lead to much worse performance. For example, assuming the input array has equal elements. Then each element would shift zero position with the above single-side partition. Therefore, the <em>n-1</em> partition use O(<em>n</em>) to remove one element, yield a total run time of O($n^2$).</p>
<p>The solution to this problem is the two-sided partition, with the following invariant:</p>
<p><img src="/content/images/2016/8/partition4.png" alt="partition4"></p>
<p>With the double-sided partition, the equal element yield the best time performance: each partition just equally divide the array. The code is:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">partion2</span><span class="params">(arr, l, u)</span>:</span></div><div class="line">    t = arr[l]</div><div class="line">    i = l + <span class="number">1</span></div><div class="line">    j = u</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">True</span>):</div><div class="line">        <span class="keyword">while</span>((i&lt;=u) <span class="keyword">and</span> (arr[i] &lt; t)):</div><div class="line">            i += <span class="number">1</span></div><div class="line">        <span class="keyword">while</span>(arr[j] &gt; t):</div><div class="line">            j -= <span class="number">1</span></div><div class="line">        <span class="keyword">if</span> i &gt; j:</div><div class="line">            <span class="keyword">break</span></div><div class="line">        swap(arr, i, j)</div><div class="line">    swap(arr, l, j)</div><div class="line">    <span class="keyword">return</span> j</div></pre></td></tr></table></figure>
<h3 id="Choose-right-element-when-partition"><a href="#Choose-right-element-when-partition" class="headerlink" title="Choose right element when partition"></a>Choose right element when partition</h3><p>So far, we simply choose the first element in partition. This would result in O($n^2$) run time if the array is already sorted. To avoid this situation we can choose a random partitioning element by swapping <code>x[l]</code> with a random entry in <code>x[l..u]</code>:</p>
<pre><code>swap(x[l], x[randint(l, u)])
</code></pre><p>A simpler technique is to shuffle the array before quick sort.</p>
<h3 id="Quicker-sorting-for-small-array"><a href="#Quicker-sorting-for-small-array" class="headerlink" title="Quicker sorting for small array"></a>Quicker sorting for small array</h3><p>When the array has small size, quick sort can be slower then insert sort. In this case, we can use a <code>cutoff</code> parameter to disable quick sort:</p>
<pre><code>if len(x) &lt; cutoff
  return
</code></pre><p>of course, after that we should call insert sort to sort the arry:</p>
<pre><code>qsort(0, n-1)
insert_sort()
</code></pre><h3 id="Put-it-together"><a href="#Put-it-together" class="headerlink" title="Put it together"></a>Put it together</h3><p>Combing all these elements together, the code of better quick sort is:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">cutoff = <span class="number">5</span> <span class="comment"># Just an example</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">qsort</span><span class="params">(x, l, u)</span>:</span></div><div class="line">    <span class="keyword">if</span> l &gt;= u:</div><div class="line">        <span class="keyword">return</span></div><div class="line">    <span class="comment"># Introduced above</span></div><div class="line">    m = partion2(x, l, u)</div><div class="line">    qsort(x, l, m<span class="number">-1</span>)</div><div class="line">    qsort(x, m+<span class="number">1</span>, u)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(arr)</span>:</span></div><div class="line">    n = len(arr)</div><div class="line">    <span class="keyword">if</span> n &lt; cutoff:</div><div class="line">        <span class="keyword">return</span></div><div class="line">    shuffle(arr)</div><div class="line">    qsort(arr, <span class="number">0</span>, n<span class="number">-1</span>)</div><div class="line">    <span class="comment"># Implementation of insert sort is omitted here</span></div><div class="line">    insert_sort(arr)</div></pre></td></tr></table></figure>
<h2 id="Takeaway"><a href="#Takeaway" class="headerlink" title="Takeaway"></a>Takeaway</h2><ol>
<li>Quick sort is anther wonderful example of divide-and-conquer. However, to make it works we should carefully consider all possible inputs.</li>
<li>Do not bother implement your own sorting algorithm. In most case the system sorting is fast enough.  </li>
</ol>

  </section>

  

<section class="post-comments">
  <div id="disqus_thread"></div>
  <script type="text/javascript">
      var disqus_shortname = 'fanzhoulll'; 
      /* * * DON'T EDIT BELOW THIS LINE * * */
      (function() {
          var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
          dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</section>


  
</article>


            <footer class="footer">

    <span class="footer__copyright">&copy; 2014-2015. | 由<a href="https://hexo.io/">Hexo</a>强力驱动 | 主题<a href="https://github.com/someus/huno">Huno</a></span>
    
</footer>
        </div>
    </div>

    <!-- js files -->
    <script src="/js/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <script src="/js/scale.fix.js"></script>
    

    

    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript"> 
        $(document).ready(function(){
            MathJax.Hub.Config({ 
                tex2jax: {inlineMath: [['[latex]','[/latex]'], ['\\(','\\)']]} 
            });
        });
    </script>


    

    <script src="/js/awesome-toc.min.js"></script>
    <script>
        $(document).ready(function(){
            $.awesome_toc({
                overlay: true,
                contentId: "post-content",
            });
        });
    </script>


    
    
    <!--kill ie6 -->
<!--[if IE 6]>
  <script src="//letskillie6.googlecode.com/svn/trunk/2/zh_CN.js"></script>
<![endif]--><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->

</body>
</html>
