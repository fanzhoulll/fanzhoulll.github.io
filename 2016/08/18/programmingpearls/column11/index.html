<!DOCTYPE html>
<html lang="en">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>Sorting (column 11) | Fan Zhou</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="IntroductionThis column introduces how to write good quick sorting algorithm. We start with the basic idea of quick sort and a naive implementation. Then we discuss some problems of the first version">
<meta property="og:type" content="article">
<meta property="og:title" content="Sorting (column 11)">
<meta property="og:url" content="http://fanzhoulll.github.io/2016/08/18/programmingpearls/column11/index.html">
<meta property="og:site_name" content="Fan Zhou">
<meta property="og:description" content="IntroductionThis column introduces how to write good quick sorting algorithm. We start with the basic idea of quick sort and a naive implementation. Then we discuss some problems of the first version">
<meta property="og:image" content="http://fanzhoulll.github.io/content/images/2016/8/partition1.png">
<meta property="og:image" content="http://fanzhoulll.github.io/content/images/2016/8/partition2.png">
<meta property="og:image" content="http://fanzhoulll.github.io/content/images/2016/8/partition3.png">
<meta property="og:image" content="http://fanzhoulll.github.io/content/images/2016/8/partition4.png">
<meta property="og:updated_time" content="2016-08-19T06:58:33.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Sorting (column 11)">
<meta name="twitter:description" content="IntroductionThis column introduces how to write good quick sorting algorithm. We start with the basic idea of quick sort and a naive implementation. Then we discuss some problems of the first version">
<meta name="twitter:image" content="http://fanzhoulll.github.io/content/images/2016/8/partition1.png">
  
    <link rel="alternate" href="/atom.xml" title="Fan Zhou" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/typing.css"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="container" class="container">
    <article id="post-programmingpearls/column11" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Sorting (column 11)
    </h1>
  

      </header>
    
    <div class="article-entry typo" itemprop="articleBody">
      
        <h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>This column introduces how to write <em>good</em> quick sorting algorithm. We start with the basic idea of quick sort and a naive implementation. Then we discuss some problems of the first version algorithm as well as some fix techniques.</p>
<h2 id="Basic-quick-sort"><a href="#Basic-quick-sort" class="headerlink" title="Basic quick sort"></a>Basic quick sort</h2><p>The basic idea of quick sort is <em>divide and conquer</em>. To sort an array we can divide it into two subarrays and recursively sort them. Specifically, we choose an pivotal <em>t</em> and <em>partition</em> the array around it by moving elements smaller than <em>t</em> to the left side of <em>t</em> and greater element to the right side. Then we recursively partition the subarrays on both sides of <em>t</em>. Finally, the entire array is sorted.</p>
<p>With this idea it is quick to write following pseudocode:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">qsort</span><span class="params">(l, u)</span>:</span></div><div class="line">    <span class="keyword">if</span> l &gt;= u:</div><div class="line">      <span class="comment"># at most one element, do nothing</span></div><div class="line">      <span class="keyword">return</span></div><div class="line">    m = partition(l, u)</div><div class="line">    qsort(l, m<span class="number">-1</span>)</div><div class="line">    qsort(m+<span class="number">1</span>, u)</div></pre></td></tr></table></figure>
<p>Next problem is how to partition array around <em>t</em>. In naive implementation, we simply choose the first element of array as pivotal <em>t</em>. Then we scan the array from left to right, and use variable <em>i</em> and <em>m</em> to maintain the following invariant:</p>
<p><img src="/content/images/2016/8/partition1.png" alt="partition1"></p>
<p>When the loop terminate we should have:</p>
<p><img src="/content/images/2016/8/partition2.png" alt="partition2"></p>
<p>Finally we swap <code>x[l]</code> and <code>x[m]</code> to get the partitioned array:</p>
<p><img src="/content/images/2016/8/partition3.png" alt="partition3"></p>
<p>The code for this single-side partition is:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">partion1</span><span class="params">(x, l, u)</span>:</span></div><div class="line">    m = l</div><div class="line">    i = l+<span class="number">1</span></div><div class="line">    <span class="keyword">while</span> i&lt;=u:</div><div class="line">        <span class="string">'''</span></div><div class="line">        Invariant:  arr[l+1 ...m] &lt;  x[l]</div><div class="line">                    arr[m+1..i-1] &gt;= x[l]</div><div class="line">        '''</div><div class="line">        <span class="keyword">if</span> x[i] &lt; x[l]:</div><div class="line">            m += <span class="number">1</span></div><div class="line">            swap(x, m, i)</div><div class="line">        i += <span class="number">1</span></div><div class="line">    swap(x, l, m)</div><div class="line">    <span class="keyword">return</span> m</div></pre></td></tr></table></figure>
<p>The best-case time complexity of quick sorting is O(<em>nlog(n)</em>). To understand why, assuming each partition divide array into two sub-arrays with equal size. The the total run time is:</p>
<pre><code>T(n) = 2*T(n/2) + O(n)
</code></pre><p>where <em>n</em> is the input array size. So we have <em>T(n) = O(nlog(n))</em>. However, this only holds when averagely speaking, the two sub-arrays after partition have equal sizes. Otherwise, the total run time would be much longer, as we will see in following section.</p>
<h2 id="Better-quick-sort"><a href="#Better-quick-sort" class="headerlink" title="Better quick sort"></a>Better quick sort</h2><h3 id="Two-sided-partition"><a href="#Two-sided-partition" class="headerlink" title="Two-sided partition"></a>Two-sided partition</h3><p>When the input array is not random, the above algorithm could lead to much worse performance. For example, assuming the input array has equal elements. Then each element would shift zero position with the above single-side partition. Therefore, the <em>n-1</em> partition use O(<em>n</em>) to remove one element, yield a total run time of O($n^2$).</p>
<p>The solution to this problem is the two-sided partition, with the following invariant:</p>
<p><img src="/content/images/2016/8/partition4.png" alt="partition4"></p>
<p>With the double-sided partition, the equal element yield the best time performance: each partition just equally divide the array. The code is:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">partion2</span><span class="params">(arr, l, u)</span>:</span></div><div class="line">    t = arr[l]</div><div class="line">    i = l + <span class="number">1</span></div><div class="line">    j = u</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">True</span>):</div><div class="line">        <span class="keyword">while</span>((i&lt;=u) <span class="keyword">and</span> (arr[i] &lt; t)):</div><div class="line">            i += <span class="number">1</span></div><div class="line">        <span class="keyword">while</span>(arr[j] &gt; t):</div><div class="line">            j -= <span class="number">1</span></div><div class="line">        <span class="keyword">if</span> i &gt; j:</div><div class="line">            <span class="keyword">break</span></div><div class="line">        swap(arr, i, j)</div><div class="line">    swap(arr, l, j)</div><div class="line">    <span class="keyword">return</span> j</div></pre></td></tr></table></figure>
<h3 id="Choose-right-element-when-partition"><a href="#Choose-right-element-when-partition" class="headerlink" title="Choose right element when partition"></a>Choose right element when partition</h3><p>So far, we simply choose the first element in partition. This would result in O($n^2$) run time if the array is already sorted. To avoid this situation we can choose a random partitioning element by swapping <code>x[l]</code> with a random entry in <code>x[l..u]</code>:</p>
<pre><code>swap(x[l], x[randint(l, u)])
</code></pre><p>A simpler technique is to shuffle the array before quick sort.</p>
<h3 id="Quicker-sorting-for-small-array"><a href="#Quicker-sorting-for-small-array" class="headerlink" title="Quicker sorting for small array"></a>Quicker sorting for small array</h3><p>When the array has small size, quick sort can be slower then insert sort. In this case, we can use a <code>cutoff</code> parameter to disable quick sort:</p>
<pre><code>if len(x) &lt; cutoff
  return
</code></pre><p>of course, after that we should call insert sort to sort the arry:</p>
<pre><code>qsort(0, n-1)
insert_sort()
</code></pre><h3 id="Put-it-together"><a href="#Put-it-together" class="headerlink" title="Put it together"></a>Put it together</h3><p>Combing all these elements together, the code of better quick sort is:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">cutoff = <span class="number">5</span> <span class="comment"># Just an example</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">qsort</span><span class="params">(x, l, u)</span>:</span></div><div class="line">    <span class="keyword">if</span> l &gt;= u:</div><div class="line">        <span class="keyword">return</span></div><div class="line">    <span class="comment"># Introduced above</span></div><div class="line">    m = partion2(x, l, u)</div><div class="line">    qsort(x, l, m<span class="number">-1</span>)</div><div class="line">    qsort(x, m+<span class="number">1</span>, u)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(arr)</span>:</span></div><div class="line">    n = len(arr)</div><div class="line">    <span class="keyword">if</span> n &lt; cutoff:</div><div class="line">        <span class="keyword">return</span></div><div class="line">    shuffle(arr)</div><div class="line">    qsort(arr, <span class="number">0</span>, n<span class="number">-1</span>)</div><div class="line">    <span class="comment"># Implementation of insert sort is omitted here</span></div><div class="line">    insert_sort(arr)</div></pre></td></tr></table></figure>
<h2 id="Takeaway"><a href="#Takeaway" class="headerlink" title="Takeaway"></a>Takeaway</h2><ol>
<li>Quick sort is anther wonderful example of divide-and-conquer. However, to make it works we should carefully consider all possible inputs.</li>
<li>Do not bother implement your own sorting algorithm. In most case the system sorting is fast enough.  </li>
</ol>

      
    </div>
    <footer class="article-footer">
      <ul class="article-meta">
        <li>
          <span class="label">Published Date:</span>
          <a href="/2016/08/18/programmingpearls/column11/" class="article-date">
  <time datetime="2016-08-18T12:04:54.000Z" itemprop="datePublished">2016-08-18</time>
</a>

        </li>
        
          <li>
            <span class="label">Category:</span>
            
  <div class="article-category">
    <a class="article-category-link" href="/categories/Notes-of-Programming-Pearls/">Notes of Programming Pearls</a>
  </div>


          </li>
        
        
          <li>
            <span class="label">Tag:</span>
            
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/programming-pearls/">programming pearls</a></li></ul>


          </li>
        
        <hr/>
      </ul>
    </footer>
  </div>
  
    
<nav id="article-nav" class="article-nav">
  
    <a href="/2016/08/19/programmingpearls/column12/" id="article-nav-newer" class="article-nav-link-wrap newer">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          A Sample Problem (column 11)
        
      </div>
    </a>
  
  
    <a href="/2016/08/16/programmingpearls/column10/" id="article-nav-older" class="article-nav-link-wrap older">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Squeezing Space (column 10)</div>
    </a>
  
</nav>


  
</article>


  <section id="comments" class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>
  </section>


  </div>
  
    <footer id="footer" class="post-footer footer">
      <hr/>
      <div id="footerContent" class="footer-content">
        <p>footnote2</p>


      </div>
    </footer>

  
  <script>
   var disqus_shortname = 'fanzhoulll';
   
   var disqus_url = 'http://fanzhoulll.github.io/2016/08/18/programmingpearls/column11/';
   
   (function(){
     var dsq = document.createElement('script');
     dsq.type = 'text/javascript';
     dsq.async = true;
     dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
     (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
   })();
  </script>


<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/typing.js"></script>
<!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->







  </div><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
</body>
</html>
